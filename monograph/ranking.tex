Como dito anteriormente, a técnica de \emph{ranking reduzido a classificação} aplica uma transformação à base original antes da etapa de treinamento do classificador e modifica a etapa de avaliação a fim de ordenar as instâncias.

A transformação consiste em formar novas instâncias a partir de pares entre instâncias de classes diferentes. A ordem em que as instâncias aparecem no par é relevante, assim, se existe um par $\langle i_\alpha, i_\beta \rangle$, deve existir também um par $\langle i_\beta, i_\alpha \rangle$. Além disso, as classes das duas instâncias que formam um par são combinadas a fim de gerar uma nova classe para a nova instância.

Essa transformação foi implantada separando a base de treinamento em dois subconjuntos, um subconjunto $S_0$ com as instâncias de classe $0$ e outro, $S_1$, com as instâncias de classe $1$, e efetuando o produto cartesiano entre os dois conjuntos da seguinte maneira $S_r = (S_0 \times S_1) \cup (S_1 \times S_0)$.

Após a aplicação do produto cartesiano, uma instância da base resultante tem a forma $\langle (A_\alpha, C_\alpha), (A_\beta, C_\beta) \rangle$. As classes das duas instâncias devem ser combinadas em uma nova classe, isso se dá com o uso do operador $1$. Ao fim desse processo, uma instancia da nova base terá forma $\langle (A_\alpha, A_\beta), 1 \cdot (C_\alpha < C_\beta)$.

O operador $1$, aplicado para obter a classe da nova instância, retorna $1$, se o resultado da expressão avaliada é verdadeiro, ou $0$, se o resultado da expressão é falsa. Como o argumento para o operador é $C_\alpha < C_\beta$, se $C_\alpha$ valer $1$, a classe da nova instância será $0$, se valer $0$, a classe da nova instância será $1$. A transformação da base é o treinamento do classificador compõe um algoritmo de nome \emph{AUC-Train} (algoritmo \ref{alg:auc-train}).

\begin{algorithm}
    Let $S' = \{\langle (x_1, x_2), 1 \cdot (y_1 < y_2) \rangle : (x_1, y_1), (x_2, y_2) \in S and y_1 \neq y_2\}$
    \Return{return $c = A(S')$}
    
    \caption{AUC-Train}
    \label{alg:auc-train}
\end{algorithm}

A modificação da etapa de avaliação tem como objetivo usar as previsões do classificador treinado pelo \emph{AUC-Train} para gerar o \emph{ranking} da base de avaliação. O algoritmo que efetua a ordenação recebe o nome de \emph{Tournament}, torneio em português. O porquê do nome é devido a idéia do algoritmo se assemelhar muito a uma competição em que muitos competidores participam, formando um \emph{ranking} de acordo com suas performances.

Continuando a analogia com uma competição, a performance de cada instância na avaliação é medida como a quantidade de "vitórias" que essa instância obteve diante das outras instâncias na base de avaliação. Para gerar o \emph{ranking}, basta promover o embate entre todas as instâncias na base e ordenar pelo número de "vitórias".

Como desejamos ordenar as instâncias de forma que as que tenham maior chance de pertencer à classe $0$ estejam no topo, a semântica de "vitoria" é tal que, entre duas instâncias competindo, a instância vencedora tem maior chance de pertencer à classe $0$. Quem define a instância vitoriosa em um embate entre duas instâncias é a previsão do classificador binário.

Tecnicamente, um embate entre as instâncias $i_\alpha$ e $i_\beta$ consiste em criar uma nova instância com formato $\langle (A_\alpha, A_\beta)\rangle$ e submetê-la à classificação; se a classe prevista da nova instância for $1$, $i_\alpha$ ganha, se for $0$, $i_\beta$ ganha. Nota-se que o formato da instância a ser classificada é o mesmo que o de uma instância usada no treinamento do classificador, exceto pela ausência de classe. O algoritmo \ref{alg:tournament} demonstra o processo de ordenação.

\begin{algorithm}
    For $x \in U$, let $deg(x) = |\{x':c(x, x') = 1, x' \in U\}|$
    Sort U in descending order of deg(x), breaking ties arbitrarily
    
    \caption{Tournament}
    \label{alg:tournament}
\end{algorithm}

Uma das vantagens da técnica de \emph{ranking reduzido a classificação} é que o uso de um algoritmo de aprendizado para classificação é transparente. Essa característica possibilitou o uso dos algoritmos de classificação existentes na ferramenta \emph{WEKA}.

O principal ponto negativo é a performance da técnica no que diz respeito a tempo. Os algoritmos \emph{AUC-Train} (\ref{alg:auc-train}) e \emph{Tournament} (\ref{alg:tournament}) que constituem o cerne da técnica de \emph{ranking reduzido a classificação} possuem elevada complexidade assintótica.


\section{Estudo da Complexidade Assintótica}

Assim como a maioria das técnicas de aprendizagem supervisionada, o \emph{ranking reduzido a classificação} pode ser dividido em duas partes: a primeira é o treinamento de um ordenador e a segunda é a avaliação do ordenador treinado.

Os principais algoritmos nas etapas de treinamento e avaliação são, respectivamente, \emph{AUC-Train} e \emph{Tournament}. A complexidade da técnica de \emph{ranking reduzido a classificação} será estudada a partir das complexidades desses dois algoritmos separadamente.

Para esse estudo, considera-se como entrada para os algoritmos uma base $S$ com $n$ instâncias das quais $k$ possuem a classe $0$ e $n - k$ possuem a classe $1$.

O algoritmo \ref{alg:auc-train} executa em três etapas:

\begin{enumerate}
    \item particionar a base de treinamento em duas bases $S_0$ e $S_1$; $S_0$ possui as instâncias de classe $0$ e $S_1$ possui as instâncias de classe $1$;
    \item aplicar o produto cartesiano duas vezes de forma que o conjunto de treinamento seja $S' \gets S_0 \times S_1 \cup S_1 \times S_0$;
    \item iterar sobre a base de treinamento $S'$ aplicando o operador $1$ às instancias a fim de definir suas classes.
\end{enumerate}

Em questão de custo computacional, o tempo de execução do algoritmo \emph{AUC-Train} é composto pela soma dos tempos de particionamento da base de treinamento; da aplicação de dois produtos cartesianos e da geração das novas instâncias para treinamento do classificador.

Para o particionamento da base, basta iterar uma vez pela base original incluindo as instâncias de classe $0$ no conjunto $S_0$ e as de classe $1$ no conjunto $S_1$, como mostrado no algoritmo \ref{alg:partition}. Essa etapa executa sempre em tempo $O(n)$.

\begin{algorithm}
    \Entrada{Conjuntos de instâncias $S$}
    \Saida{Partições de instâncias $S_0, S_1$}

        $S_0, S_1 \gets \emptyset$

        \ParaTodo{$i \in S$}{
            \eSe{$i(C) = 0$}{
                $S_0 \gets S_0 \cup {i}$
            }{
                $S_1 \gets S_1 \cup {i}$
            }
        }

        \Retorna{$S_0 \; S_1$}

    \caption{Particionamento da base}
    \label{alg:partition}
\end{algorithm}

Após o particionamento da base, gera-se o conjunto $S'$ a partir de produtos cartesianos: $S' \gets (S_0 \times S_1) \cup (S_1 \times S_0)$. O meio convencional de solucionar o produto cartesiano é aninhar dois \emph{loops} como mostrado no algoritmo \ref{alg:cross-product}.

\begin{algorithm}
    \Entrada{Conjuntos de instâncias $S_{\alpha}$ e $S_{\beta}$}
    \Saida{Produto cartesiano $S_{\times} = S_{\alpha} \times S_{\beta}$}

    $S_{\times} \gets \emptyset$

    \Se{$S_{\alpha} \neq \emptyset \wedge S_{\beta} \neq \emptyset$}{
        \ParaTodo{$\alpha \in S_{\alpha}$}{
            \ParaTodo{$\beta \in S_{\beta}$}{
                $S_{\times} \gets S_{\times} \cup \{ \langle \alpha, \beta \rangle \}$
            }
        }
    }

    \Retorna{$S_{\times}$}

    \caption{Produto cartesiano}
    \label{alg:cross-product}
\end{algorithm}

Para o produto cartesiano, o melhor caso ocorre quando $k = 0$ ou $k = n$ com tempo computacional de $O(1)$. Nesses casos, todas as instâncias pertencem à mesma classe e $S_{\alpha} = \emptyset$ ou $S_{\beta} = \emptyset$, dessa forma o produto cartesiano não executa os loops.

No caso médio, parte-se da hipótese que todas as entradas são uniformemente prováveis. A probabilidade de uma entrada para um dado $k$ é $\frac{1}{n}$ e a quantidade de iterações geradas por essa entrada é $k \cdot (n - k)$. Partindo desses dados, a complexidade do caso médio pode ser calculada pela fórmula $O(f_{avg}(n))$, na qual:

\[f_{avg}(n) = \sum_{k = 0}^{n} \frac{k \cdot (n - k)}{n}\]

Desenvolvendo o somatório:

\begin{align*}
    f_{avg}(n) &= \frac{1}{n} \cdot \sum_{k = 0}^{n} k(n - k) \\
               &= \frac{1}{n} \cdot \sum_{k = 0}^{n} kn - k^2 \\
               &= \frac{1}{n} \cdot \left(\sum_{k = 0}^{n} kn - \sum_{k = 0}^{n} k^2\right) \\
               &= \frac{1}{n} \cdot \left(n \cdot \sum_{k = 1}^{n} k - \sum_{k = 1}^{n} k^2\right) \\
               &= \frac{1}{n} \cdot \left(n \cdot \frac{n(n + 1)}{2} - \frac{n(n + 1)(2n + 1)}{6}\right) \\
               &= \frac{1}{n} \cdot \frac{n^3 + n}{6} = \frac{n^2 -1}{6}
\end{align*}

Logo, o caso médio é igual a $O(f_{avg}) = O(\frac{n^2 -1}{6}) = O(n^2)$.

O pior caso acontece quando $k = \frac{n}{2}$, nesse caso a base de treinamento possui metade das instâncias com classe $0$ e a outra metade com classe $1$. O produto cartesiano ocorrerá em dois conjuntos com $\frac{n}{2}$ instâncias, resultando na complexidade assintótica $O(\frac{n}{2} \cdot \frac{n}{2}) = O(\frac{n^2}{4}) = O(n^2)$.

Para a definicão das novas instâncias, basta iterar sobre as tuplas em $S'$ transformando-as em novas instâncias compostas pelos atributos das instâncias que compõe a tupla e uma class gerada através do operador $1$. Esse processo é descrito nos algoritmos \ref{alg:one} e \ref{alg:transform}

\begin{table}[h]
    \centering
    \begin{tabular}{ c | c c | c }
        \hline

        Caso & Particionamento & Produto Cartesiano & AUC-Train \\

        \hline

        Melhor & $O(n)$ & $O(1)$ & $O(n) + O(1) = O(n)$ \\
        Médio & $O(n)$ & $O(n^2)$ & $O(n) + O(n^2) = O(n^2)$ \\
        Pior  & $O(n)$ & $O(n^2)$ & $O(n) + O(n^2) = O(n^2)$ \\
    
        \hline
    \end{tabular}

    \caption{Complexidade do algoritmo AUC-Train}
    \label{auc-train-complexity}
\end{table}

Analisando a tabela \ref{auc-train-complexity}, percebe-se que o gargalo do algoritmo \emph{AUC-Train} reside na aplicação do produto cartesiano. Na prática, algumas otimizações foram aplicadas ao algoritmo final escrito para o \emph{workbench WEKA}:
O algoritmo de produto cartesiano foi levemente alterado para gerar tanto o par $(x, y)$ quanto o par $(y, x)$; isso elimina a necessidade da aplicação de dois produtos cartesianos.
Apesar da aplicação dessas otimizações, a complexidade do algoritmo se manteve inalterada.

O algoritmo de produto cartesiano é levemente alterado para gerar tanto o par $(x, y)$ quanto o par $(y, x)$, isso evita a necessidade de aplicar duas vezes o produto cartesiano; o uso do operador $1$ está embutido no algoritmo de produto cartesiano e não acrescenta complexidade extra ao algoritmo, entre outras.

Para o algoritmo de torneio, o pior caso, o caso médio e o melhor caso apresentam o mesmo tempo de execução, pois é sempre necessário formar todos os pares de instâncias possíveis a fim de obter a ordem de todas as instâncias. Como mostrado no algoritmo \ref{alg:tournament}, a operação de gerar todos os pares aninha dois \emph{loops}o que resulta em um custo de ordem $O(n^2)$, onde $n$ é o tamanho da base a ser ordenada.

Tanto o algoritmo \emph{AUC-Train} quanto o \emph{Tournament} apresentam tempos elevados de execução. A prática de comparar as instâncias em pares onera tanto os processos de treinamento e de ordenação e, usando bases extensas, o tempo de execução do algoritmo degrada consideravelmente. Essa característica levou à busca de alternativas para tornar ambos treinamento e ordenação mais rápidos.

Duas abordagens foram consideradas para amortizar a complexidade do algoritmo: uma para a fase de treinamento e outra para a fase de geração do \emph{ranking}. Para a fase de classificação, foi pensada uma estratégia de amostragem da base original e votação entre classificadores e para a geração do \emph{ranking}, foi pensada uma estratégia de torneio baseada em \emph{quicksort}.

\section{Otimização do treinamento: Amostragem e Votação}
O algoritmo original chama a etapa de treinamento de AUC-Train. Nessa etapa, são feitas combinações entre as instâncias de classe $0$ e de classe $1$, como mostrado no \emph{algoritmo \ref{alg:auc-train}}.

Esse algoritmo de mesclagem das instâncias é executado uma vez e seu resultado é usado como massa de dados para um algoritmo de aprendizado; no caso específico dessa implantação, um classificador.

O custo total do AUC-Train é composto pelos custos da etapa de mesclagem e do algoritmo de aprendizagem somados. Vale ressaltar que a etapa de mesclagem tem um tempo maior de execução; a otimização endereça esse problema especificamente.

Na estratégia adotada para reduzir o tempo de mesclagem figuram duas técnicas conhecidas em \emph{data mining}, a primeira é efetuar uma amostragem do conjunto original e a segunda é promover uma votação entre vários classificadores treinados com as amostragens como massa de dados.

\begin{algorithm}
    \Entrada{Partições de instâncias $S_0$, $S_1$; Número de amostragens $n$; Tamanho da amostra $s$}
    \Saida{Produto cartesiano $S_{\times} = S_{\alpha} \times S_{\beta}$}

    $V \gets \emptyset$

    \For{$i=1 \to n$}{
        \For{$j=1 \to s$}{
            $S_{s1} \gets S$
        }
    }

    \Retorna{$S_{\times}$}

    \caption{AUC-Train com amostragem e votação}
    \label{alg:auc-train-amostragem-votacao}
\end{algorithm}

O parâmetro de pares por instância indica a quantidade pares $(i, y)$ que a instância $i$ deve formar; $y$ é qualquer instância de classe antagônica à classe de $i$.

Supondo que todos os classificadores possuem a mesma configuração, não há sentido em executar uma votação em que os classificadores foram aprendidos a partir da base de treinamento completa. Isso resultaria em votos iguais para todos os classificadores.

% \begin{algorithm}
% \begin{algorithmic}
% 
% 
% \STATE $V\,\gets\,\emptyset$
% 
% \FOR{$i\,=\,1,\;i\,\to\,iterations$}
% \STATE Let $S_{sample} = S' : S' \subset S_1 \wedge |S'| = limit$
% \STATE Let $S_{train} = \{\langle ((x_{0},\,x_{s}),\, 1),\; ((x_{s},\, x_{0}),\,0) \rangle:
%        (x_{0},\,y_{0})\,\in\,S_{0}\,\wedge\,
%        (x_{s},\,y_{s})\,\in\,S_{sample}\}$
% \STATE $c\,\gets\,A(S_{train})$
% \STATE $V\,\gets\,V\,\bigcup\,\{c\}$
% \ENDFOR
% 
% \caption{AUC-Train com amostragem}
% \label{alg:auc-train-amostragem-votacao}
% 
% \end{algorithmic}
% \end{algorithm}

O produto gerado pelo algoritmo \ref{alg:auc-train-amostragem-votacao} é um conjunto de classificadores treinados a partir de amostragens do conjunto original. Se passarmos os parâmetros $limit=all$ e $iterations=1$, ele gera o mesmo resultado do algortimo descrito por {{langford}}.


\section{Otimização da ordenação: Quicksort}
A etapa de ordenação original é chamada de \emph{torneio}. Nessa abordagem, todas as instâncias do conjunto a ser ordenado são comparadas entre si com base no classificador obtido no treinamento e recebem uma pontuação. As instâncias de maior pontuação assumem as primeiras posições no \emph{ranking}. A proposta de otimização baseia-se em uma adaptação do algoritmo de quicksort para ordenar as instâncias do \emph{ranking}.

% \begin{algorithm}
% \begin{algorithmic}
% 
% \FORALL{$x\,\in\,U$}
% \STATE $deg(x) = |\{x': c(x, x')=1, x'\in U\}|$
% \ENDFOR
% \STATE Ordene U de forma descendente com base em $deg(x)$, resolva os empates arbitrariamente
% 
% \caption{Degree}
% \label{alg:degree}
% 
% \end{algorithmic}
% \end{algorithm}


\section{Definições}
Algumas definições necessárias para o funcionamento do algoritmo final.

\section{Algoritmo final}

% \begin{algorithm}
% \begin{algorithmic}
% 
% \STATE $c \gets train(TS, LA, pairs, iterations)$
% \STATE $rank(RS, c, quicksort)$
% 
% \caption{Algoritmo final do \emph{Ranking}}
% \label{alg:ranking}
% 
% \end{algorithmic}
% \end{algorithm}
